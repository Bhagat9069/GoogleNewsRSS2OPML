#!/usr/bin/env python

OPML_HEADER = """\
<?xml version="1.0" encoding="UTF-8"?>
<!-- Generated by gn2opml -->
<opml version="1.0">
	<head>
		<title>Google News</title>
	</head>
	<body>
		<outline text="Google News" title="Google News">
"""

OPML_OUTLINE_FEED = """\
			<outline text="{title}" title="{title}" type="rss" htmlUrl="{url}" xmlUrl="{url}" />
"""

OPML_FOOTER = """\
		</outline>
	</body>
</opml>
"""

URL_TOPIC    = "https://news.google.com/news/rss/headlines/section/topic/{topic}"
URL_LOCATION = "https://news.google.com/news/rss/headlines/section/geo/{location}"
URL_QUERY    = "https://news.google.com/news/rss/search/section/q/{query}"

DEFAULT_TOPICS = """
WORLD
NATION
BUSINESS
TECHNOLOGY
ENTERTAINMENT
SPORTS
SCIENCE
HEALTH
""".split()



import argparse

parser = argparse.ArgumentParser()

parser.add_argument("-o", "--output", help="output file name (default: print to stdout)")

parser.add_argument("-c", "--country",   default="us", help="country / Google News edition (default: us)")
parser.add_argument("-l", "--language",  default="en", help="language (default: en)")

parser.add_argument("-t", "--topics",    metavar="TOPIC",    nargs="*", default=DEFAULT_TOPICS, help="list of topics, will be converted to uppercase (default: {})".format(" ".join(DEFAULT_TOPICS)))
parser.add_argument("-g", "--locations", metavar="LOCATION", nargs="*", default=[],             help="list of geographic locations (default: None)")
parser.add_argument("-q", "--queries",   metavar="QUERY",    nargs="*", default=[],             help="list of search queries (default: None)")

clargs = parser.parse_args()



import itertools
import requests
import lxml.objectify

def get_title(rss_url):
    """Download rss from given url and extract the title"""
    req = requests.get(rss_url)
    txt = req.text.encode('utf-8')
    rss = lxml.objectify.fromstring(txt)
    title = rss.channel.title
    return title.text.decode('utf-8')

def clean_title(title):
    """Remove superfluous things from title"""
    tmp = " - Google News"
    if title.endswith(tmp):
        title = title[:-len(tmp)]
    return title

def topic_locale(language=None, country=None):
    """Generate the locale string, e.g., '.en_us', which is appended to the topic"""
    if language is None and country is None:
        return ""
    if country is None:
        country = language
    if language is None:
        language = country
    return ".{}_{}".format(language, country)

def language_settings(ned=None, gl=None, hl=None):
    """
    Generate the language settings string, which is appended to the url
    From the documentation:
        ned = EDITION limits results to a specific edition. Possible values: editions
        gl  = COUNTRY boosts search results from a specific country of origin. Possible values: country codes
        hl  = LANGUAGE sets host language. Default: "us". Possible values: languages
    Turns out, only the edition is needed...
    """
    res = []
    if ned is not None:
        res.append("ned=" + ned)
    if gl is not None:
        res.append("gl=" + gl)
    if hl is not None:
        res.append("hl=" + hl)
    return "?" + "&".join(res) if res else ""

def gen_topic_urls(topics, locale):
    """
    Generate urls for the given topics
    all topics will be converted to uppercase and locale will be appended to each url
    """
    for topic in topics:
        topic = topic.upper() # topics apparently have to be uppercase
        url = URL_TOPIC.format(topic=topic)
        url += locale
        yield url

def gen_location_urls(locations):
    """Generate urls for the given locations"""
    for location in locations:
        yield URL_LOCATION.format(location=location)

def gen_query_urls(queries):
    """Generate urls for the given search queries"""
    for query in queries:
        yield URL_QUERY.format(query=query)

def gen_opml_entries(urls, language):
    """Format urls to opml entries, language will be appended to each url"""
    for url in urls:
        url += language
        title = get_title(url)
        title = clean_title(title)
        yield OPML_OUTLINE_FEED.format(title=title, url=url)

def chain_as_list(*args):
    """Chain all arguments via itertools.chain and return as list"""
    chained = itertools.chain(*args)
    return list(chained)

def concatenate(strs):
    """Concatenate all arguments assuming they are strings"""
    return "".join(strs)

def write(data, filename=None):
    """Write data to file if filename is given, to stdout otherwise"""
    if filename is not None:
        output = open(filename, "w")
    else:
        from sys import stdout as output

    output.write(result)

    if filename is not None:
        output.close()





if __name__ == "__main__":
    lang_top = topic_locale(clargs.language, clargs.country)
    lang_set = language_settings(clargs.country)

    urls_topic    = gen_topic_urls(clargs.topics, lang_top)
    urls_location = gen_location_urls(clargs.locations)
    urls_query    = gen_query_urls(clargs.queries)

    urls = chain_as_list(urls_topic, urls_location, urls_query)
    if not urls:
        raise SystemExit("No results found for given options.")

    opml_entries = gen_opml_entries(urls, lang_set)
    opml_entries = concatenate(opml_entries)

    result = OPML_HEADER + opml_entries + OPML_FOOTER
    write(result, clargs.output)



